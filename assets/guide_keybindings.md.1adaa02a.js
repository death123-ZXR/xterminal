import{_ as e,o as t,c as o,V as a}from"./chunks/framework.1b5edb90.js";const y=JSON.parse('{"title":"Key Bindings","description":"","frontmatter":{},"headers":[],"relativePath":"guide/keybindings.md","filePath":"guide/keybindings.md"}'),n={name:"guide/keybindings.md"},r=a('<h1 id="key-bindings" tabindex="-1">Key Bindings <a class="header-anchor" href="#key-bindings" aria-label="Permalink to &quot;Key Bindings&quot;">​</a></h1><p>These are shortcuts to enhance the command-line experience. Basically, they are keyboard keys bound to your terminal to provide functionality that would ease the use.</p><div class="info custom-block"><p class="custom-block-title">Note</p><p>Key bindings to your terminal only work when the terminal is <strong>focused</strong> so that the action triggered is bound to that instance.</p></div><h2 id="arrowup-key" tabindex="-1">ArrowUp Key <a class="header-anchor" href="#arrowup-key" aria-label="Permalink to &quot;ArrowUp Key&quot;">​</a></h2><p>When the <code>ArrowUp</code> key is pressed, it continously interates through the previously run commands as it sets that command as the current input.</p><p>It runs through the history setting the corresponding command at a certian index as the current terminal input.</p><div class="info custom-block"><p class="custom-block-title">Note</p><p>No duplicate commands are pushed to the history stack. If the previously run command is the same as the current, the latter won&#39;t be pushed to the history stack.</p></div><p>All in all, this key goes backwards in history.</p><h2 id="arrowdown-key" tabindex="-1">ArrowDown Key <a class="header-anchor" href="#arrowdown-key" aria-label="Permalink to &quot;ArrowDown Key&quot;">​</a></h2><p>In case the <code>ArrowUp</code> key is hit several times, to return to the most recently run commands, the <code>ArrowDown</code> key is used.</p><p>The <code>ArrowDown</code> key goes foreward in history by setting the most recently run command as the current input. If no previously run commands, the input is set to the previously buffered input, nothing otherwise.</p><h2 id="tab-key" tabindex="-1">Tab key <a class="header-anchor" href="#tab-key" aria-label="Permalink to &quot;Tab key&quot;">​</a></h2><p>Just like in real terminal applications, the <code>Tab</code> key provides the autocomplete future for the commands starting with the characters currently present in the terminal input.</p><p>If the terminal input is empty, then there are no characters to match.</p><p>For effective autocompletion, you must set a function that will work out the best matches. This is can be done using the <code>setCompleter()</code> method on the terminal instance which is discussed on the next page.</p><h2 id="next-steps" tabindex="-1">Next Steps <a class="header-anchor" href="#next-steps" aria-label="Permalink to &quot;Next Steps&quot;">​</a></h2><p>Enhance a rich interactive command-line interface with tab autocompletion.</p>',17),i=[r];function s(c,h,d,l,p,u){return t(),o("div",null,i)}const k=e(n,[["render",s]]);export{y as __pageData,k as default};
